<!DOCTYPE html>
<html>

<head>
	<title>Planar Parameterization</title>
	<script src="p5.js"></script>
	<style>
		canvas {
			display: block;
			margin: 0 auto;
		}
	</style>
</head>



<body>
	<script>
		let rows = 50;
		let cols = 50;
		let scl = 250;
		let w = 1200;
		let h = 600;

		let plane = [];

		let initialPlane = [];
		let finalShape = [];

		let lerpVal = 1;
		let lerpDir = 0;

		let count = 0;
		let countMax = 50;

		let camX = 0;
		let camY = -200;
		let camZ = 500;

		function setup() {
			createCanvas(w, h, WEBGL);
			angleMode(DEGREES);

			for (let i = 0; i < rows; i++) {
				finalShape[i] = [];
				initialPlane[i] = [];
				for (let j = 0; j < cols; j++) {
					//let u = map(i/rows,0,1-1/rows,0,2*Math.PI)-Math.PI/2;
					//let v = map(j/cols,0,1-1/cols,0,2*Math.PI)+Math.PI;
					let u = map(i/rows,0,1-1/rows,0,1);
					let v = map(j/cols,0,1-1/cols,0,15*180);
					finalShape[i][j] = rose(u,v)[0].mult(scl);
					initialPlane[i][j] = createVector(-10*i+rows/2*10,scl*0,10*j-cols/2*10);
				}
			}
		}

		function donut(u, v) {
			return createVector((cos(v)+2)*cos(u),
					(cos(v)+2)*sin(u),
					sin(v));//-u/2;
		}

		// Rose[x_, theta_] := Module[
		// 	{phi = (Pi/2)Exp[-theta/(8 Pi)], 
		//	X = 1 - (1/2) ( (5/4) (1 - Mod[3.6 theta, 2 Pi]/Pi)^2 - 1/4)^2}, 
		// 	y = 1.95653 x^2 (1.27689 x - 1)^2 Sin[phi];
		// 	r = X(x Sin[phi] + y Cos[phi]); 
		// 	{r Sin[theta], r Cos[theta], X(x Cos[phi] - y Sin[phi]), EdgeForm[]}
		// ];
		// ParametricPlot3D[Rose[x, theta], {x, 0, 1}, {theta, -2 Pi, 15 Pi}, PlotPoints -> {25, 576}, LightSources -> {{{0, 0, 1}, RGBColor[1, 0, 0]}}, Compiled -> False]

		function rose(x, theta) {
			let phi = (180/2)*exp(-theta/(8*180));
			let petalCut = 1 - (.5) * pow(1-((3.6*theta%360)/180),4);
			let hangDown = 2*pow(x,2)*pow(1.3*x-1,2)*sin(phi);

			let pX =  petalCut * x * sin(phi) * sin(theta);
			let pY = petalCut * (x * cos(phi) - hangDown*sin(phi));
			let pZ =  petalCut * x * sin(phi) * cos(theta);

			return [createVector(pX, -pY, pZ), [205, -x*50+100, x*50+50]]
		}

		function draw() {
			for (let i = 0; i < rows; i++) {
				plane[i] = [];
				for (let j = 0; j < cols; j++) {
					plane[i][j] = p5.Vector.lerp(initialPlane[i][j], finalShape[i][j], lerpVal)
				}
			}
			
			if (lerpVal > 1 || lerpVal < 0) {
				count += 1;
				if (count > countMax) {
					lerpDir *= -1;
					count = 0;
					lerpVal += .01*lerpDir;
				}
			} else {
				lerpVal += .01*lerpDir;
			}
			
			background(255);

			//stroke(0,100,0);
			noStroke();
			//noFill();

			// move and rotate camera
			orbitControl();

			// draw terrain
			for (let i = 0; i < rows-1; i++) {
				
				for (let j = 0; j < cols-1; j++) {
					beginShape(POINTS);
					//fill(0,0,i/rows*100+155);
					fill(map(noise(i/rows*3), 0, 1, 0, 255), map(noise(j/cols*3), 0, 1, 0, 255), 0)

					vertex(plane[i][j].x, plane[i][j].y, plane[i][j].z);
					vertex(plane[i+1][j].x, plane[i+1][j].y, plane[i+1][j].z);
					vertex(plane[i+1][j+1].x, plane[i+1][j+1].y, plane[i+1][j+1].z);

					endShape();

					beginShape(POINTS);

					//fill(map(noise(i/rows*3), 0, 1, 0, 100), map(noise(j/cols*3), 0, 1, 0, 100),0)

					vertex(plane[i][j].x, plane[i][j].y, plane[i][j].z);
					vertex(plane[i][j+1].x, plane[i][j+1].y, plane[i][j+1].z);
					vertex(plane[i+1][j+1].x, plane[i+1][j+1].y, plane[i+1][j+1].z);

					endShape();
				}
			}

			//fillLRSeams();
			//fillTBSeams();
			//fillLastSeam();
		}

		function fillLRSeams() {
			for (let i = 0; i < rows-1; i++) {
				beginShape();
				fill(0,0,i/rows*100+155);
				
				vertex(plane[i][cols-1].x, plane[i][cols-1].y, plane[i][cols-1].z);
				vertex(plane[i+1][cols-1].x, plane[i+1][cols-1].y, plane[i+1][cols-1].z);
				vertex(plane[i+1][0].x, plane[i+1][0].y, plane[i+1][0].z);

				vertex(plane[i][cols-1].x, plane[i][cols-1].y, plane[i][cols-1].z);
				vertex(plane[i][0].x, plane[i][0].y, plane[i][0].z);
				vertex(plane[i+1][0].x, plane[i+1][0].y, plane[i+1][0].z);
				
				endShape();
			}
		}

		function fillTBSeams() {
			for (let j = 0; j < cols-1; j++) {
				beginShape();
				fill(0,0,155);
				vertex(plane[rows-1][j].x, plane[rows-1][j].y, plane[rows-1][j].z);
				vertex(plane[0][j].x, plane[0][j].y, plane[0][j].z);
				vertex(plane[0][j+1].x, plane[0][j+1].y, plane[0][j+1].z);

				vertex(plane[rows-1][j].x, plane[rows-1][j].y, plane[rows-1][j].z);
				vertex(plane[rows-1][j+1].x, plane[rows-1][j+1].y, plane[rows-1][j+1].z);
				vertex(plane[0][j+1].x, plane[0][j+1].y, plane[0][j+1].z);
				endShape();
			}
		}

		function fillLastSeam() {
			beginShape();
			fill(0,0,0/rows*100+155);
			
			vertex(plane[rows-1][cols-1].x, plane[rows-1][cols-1].y, plane[rows-1][cols-1].z);
			vertex(plane[0][cols-1].x, plane[0][cols-1].y, plane[0][cols-1].z);
			vertex(plane[0][0].x, plane[0][0].y, plane[0][0].z);

			vertex(plane[rows-1][cols-1].x, plane[rows-1][cols-1].y, plane[rows-1][cols-1].z);
			vertex(plane[rows-1][0].x, plane[rows-1][0].y, plane[rows-1][0].z);
			vertex(plane[0][0].x, plane[0][0].y, plane[0][0].z);
			
			endShape();
		}

	</script>
</body>

</html>