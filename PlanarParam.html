<!DOCTYPE html>
<html>

<head>
	<title>Planar Parameterization</title>
	<script src="p5.js"></script>
	<style>
		canvas {
			display: block;
			margin: 0 auto;
		}
	</style>
</head>



<body>
	<script>
		let rows = 32;
		let cols = 16;
		
		let scalar = 100;
		let w = 1000;
		let h = 500;

		let plane = [];

		let initialPlane = [];
		let finalShape = [];
		let colorMap = [];

		let lerpStep = 0;
		let lerpDir = -1;

		let count = 0;
		let countMax = 0;

		let camX = 0;
		let camY = -200;
		let camZ = 500;

		var drawMode;
		var collection;

		function setup() {
			createCanvas(w, h, WEBGL);
			
			angleMode(DEGREES);
			colorMode(HSB);

			struct = new Structure(rows, cols);
			donut = new Donut(rows, cols);
			spiral = new Spiral(rows, cols);
			spiralThick = new SpiralThick(rows, cols);
			rose = new Rose(rows, cols);
			roseThick = new RoseThick(256, 64);

			struct2 = new Structure(2, 40);
			meta = new Metagon(2, 40);
			
			meta.SetFocused();

			lox = new Loxodrome(rows, cols);

			// collection = new Collection([struct, donut, spiral, rose]);
			collection = new Collection([roseThick]);
			//collection = new Collection([struct2, meta]);
			collection.FillShapeForLerp(1);

			stroke(205,50,100);
			//strokeWeight(1);

			drawMode = TRIANGLES;
			noStroke();
			//noFill();

			var outShape = lox;

			var outString="POINT_LIST = [\n";
			for (let i=0; i<outShape.shape_.length; i++) {
				outString += "[";
				for (let j=0; j<outShape.shape_[i].length;j++) {
					outString+= "[" + outShape.shape_[i][j].x + "," + outShape.shape_[i][j].y + "," +outShape.shape_[i][j].z + "]"
					if (j<outShape.shape_[i].length-1) {
						outString+=",";
					}
					
				}
				outString += "]";
				if (i<outShape.shape_.length-1) {
					outString+=",";
				}
			}
			outString += "\n];";

			var a = document.createElement("a");
			a.href = window.URL.createObjectURL(new Blob([outString], {type: "text/plain"}));
			a.download = "curveData.txt";
			a.click()
			
		}

		class Structure {
			static focused;
			
			constructor(rows, cols, scl = scalar, auto=true) {
				this.rows_ = rows;
				this.cols_ = cols;
				this.scl_ = scl;

				this.shape_ = [];
				this.colorMap_ = [];

				if (auto) {
					this.CreateShape();
				}
			}

			DefineCoordinates(v, u) {
				let phi = map(u, 0, 1, 0, 1*180);
				let theta = map(v, 0, 1, 0, 2*180);

				let pX = sin(phi) * sin(theta);
				let pY = cos(phi);
				let pZ = sin(phi) * cos(theta);

				return [createVector(pX, -pY, pZ), [50, 50, 100-map(phi, 0, 1*180, 0, 100)]];
			}

			CreateShape() {
				for (let i = 0; i < this.rows_; i++) {
					this.shape_[i] = [];
					this.colorMap_[i] = [];
					for (let j = 0; j < this.cols_; j++) {
						let u = i/(this.rows_-1);
						let v = j/(this.cols_-1);

						let out = this.DefineCoordinates(u,v);
						let vect = out[0];
						let color = out[1];
						vect.mult(this.scl_);

						this.shape_[i][j] = vect;
						this.colorMap_[i][j] = color;
					}
				}
			}

			SetFocused() {
				Structure.focused = this;
			}

			Draw() {
				for (let i = 0; i < this.rows_-1; i++) {
					for (let j = 0; j < this.cols_-1; j++) {
						beginShape(drawMode);
						fill(this.colorMap_[i][j]);

						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i+1][j].x, this.shape_[i+1][j].y, this.shape_[i+1][j].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();

						
						beginShape(drawMode);
						fill(this.colorMap_[i][j][0], this.colorMap_[i][j][1], this.colorMap_[i][j][2]-10);
						
						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i][j+1].x, this.shape_[i][j+1].y, this.shape_[i][j+1].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();
					}
				}
			}
		}

		class Donut extends Structure {
			DefineCoordinates(u, v) {
				u = map(u, 0, 1, 0, 2*180);
				v = map(v, 0, 1, 0, 2*180);
				
				let pX = (cos(v)+2)*cos(u);
				let pY = (cos(v)+2)*sin(u);
				let pZ = sin(v);

				let pos = createVector(pY, -pZ, pX);
					
				let color = [100,100,50];

				return [pos, color];
			}
		}

		class Loxodrome extends Structure {
			DefineCoordinates(u, a) {
				a = map(a,0,1,0,360);
				u = map(u, 0, 1, 0, 180);
				let a2 = 5;
				let v = a2*log((tan(u/2)))*180/3.14152926;

				let r2=.02;

				let pX = sin(u)*cos(v)+r2*cos(v)*cos(a);
				let pY = cos(u)+r2*sin(a);
				let pZ = sin(u)*sin(v)+r2*sin(v)*cos(a);

				let pos = createVector(pX, pY, pZ);

				let color = [100,100,50];

				return [pos,color];
			}
		}

		class Rose extends Structure {
			DefineCoordinates(theta, r) {
				//phi = map(phi, 0, 1, 0, 2*Math.PI);
				let color = [0, -r*50+100, r*50+50];
				
				let circles = 7.5;

				theta = map(theta, 0, 1, 0, circles*2 * 180);
				let phi = 15*Math.exp(theta/1500);

				let petalCut = 1 - (1/2) * pow((1) * (1 - ((3.6*theta%360)/180)), 4);
				let hangDown = 1.95653*pow(r,2)*pow(1.27689*r-1,2)*sin(phi);

				let pX = petalCut * r * sin(phi) * sin(theta);
				let pY = petalCut * (r * cos(phi)-hangDown);
				let pZ = petalCut * r * sin(phi) * cos(theta);

				return [createVector(pX, -pY, pZ), color];
			}
		}

		class RoseThick extends Structure {
			DefineCoordinates(theta, r) {
				r = map(r, 0, 1, 0, 2);
				if (r > 1) {
					r = -(r-1)+2;
				}

				var down = 0;
				if (r >= 1) {
					down += .1;
				}
				
				let color = [0, -r%1*50+100, r%1*50+50];
				
				let circles = 7.5;

				theta = map(theta, 0, 1, 0, circles*2 * 180);
				let phi = 15*Math.exp(theta/1500);

				let petalCut = 1 - (1/2) * pow((1) * (1 - ((3.6*theta%360)/180)), 4);
				let hangDown = 1.95653*pow(r%1,2)*pow(1.27689*(r%1)-1,2)*sin(phi);

				let pX = petalCut * (r%1) * sin(phi) * sin(theta);
				let pY = petalCut * ((r%1) * cos(phi)-hangDown);
				let pZ = petalCut * (r%1) * sin(phi) * cos(theta);

				return [createVector(pX, -pY+down, pZ), color];
			}
		}

		class Spiral extends Structure {
			DefineCoordinates(v, u) {
				return [createVector(u*sin(map(v, 0, 1, 0, 7.5 * 2 * 180)),
									10*(v-1),
									u*cos(map(v, 0, 1, 0, 7.5 * 2 * 180))), [0, -u*50+100, u*50+50]];
			}
		}

		class SpiralThick extends Structure {
			DefineCoordinates(v, u) {
				u = map(u, 0, 1, 0, 2);
				if (u > 1) {
					u = -(u-1)+2;
				}
				var newV = map(v, 0, 1, 0, 7.5 * 2 * 180);
				
				var down = 0;
				if (u%1 < .75 && u%1 > .25) {
					down = .2;
				}
				
				if (u >= 1) {
					down += .2;
				}

				return [createVector(.5*sin(newV) + u%1*sin(newV),
									10*(v-1)+down,
									.5*cos(newV) + u%1*cos(newV)), [0, -u%1*50+100, u%1*50+50]];
			}
		}

		class Metagon extends Structure {
			constructor(rows, cols, scl = scalar) {
				super(rows, cols, scl, false);
				
				this.metagonData = [];

				let a = 60;

				let pointCount = 0;
				
				for (let sides = 3; pointCount < this.cols_+20 ; sides++) {
					this.metagonData.push([]);

					for (let vert = 0; vert < sides; vert++) {
						var lastPoint;
						if (vert > 0) {
							lastPoint = this.metagonData[this.metagonData.length-1][this.metagonData[this.metagonData.length-1].length-1];
						} else {
							if (this.metagonData.length == 1) {
								this.metagonData[0][0] = createVector(0,0);
								pointCount++;
								lastPoint = this.metagonData[0][0];
							} else {
								lastPoint = this.metagonData[this.metagonData.length-2][this.metagonData[this.metagonData.length-2].length-3];
								a+=2*360/(sides-1)
							}
						}
						this.metagonData[this.metagonData.length-1].push(createVector(lastPoint.x+cos(a), lastPoint.y+sin(a)));
						pointCount++;

						a -= 360/sides;
					}
				}
				this.CreateShape();
			}
			
			DefineCoordinates(v, u) {
				v = floor(map(v, 0, 1, 0, this.cols_));
				//console.log(u,v);
				
				var shape;
				var extra;

				color = [(-shape/5*150+360+120)%360,255,255]
				
				if (v < 2) {
					shape = 0;
					extra = floor(v);
				} else {
					shape = sqrt(2*v-1.75)-.5;
					extra = floor(v-(floor(shape)*floor(shape)+floor(shape)+2)/2);
				} 

				console.log(floor(shape), extra);
				
				return [createVector(this.metagonData[floor(shape)][floor(extra)].x*u,-v/10*(1-u),this.metagonData[floor(shape)][floor(extra)].y*u), color];
			}
		}

		class Collection {
			constructor(structs) {
				// for (let i = 0; i < structs.length-1; i++) {
				// 	assert(structs[i].rows_ == structs[i+1].rows_ && structs[i].cols_ == structs[i+1].cols_, "Array sizes not compatible");
				// }

				this.structures_ = structs;
				this.shape_ = structs[0].shape_;
				this.colorMap_ = structs[0].colorMap_;
				this.rows_ = structs[0].rows_;
				this.cols_ = structs[0].cols_;
			}

			GetCoord(u, v, index, subLerp) {
				let pos = p5.Vector.lerp(this.structures_[index].shape_[u][v], this.structures_[index+1].shape_[u][v], subLerp)
				let color = p5.Vector.lerp(createVector(this.structures_[index].colorMap_[u][v][0],
													this.structures_[index].colorMap_[u][v][1],
													this.structures_[index].colorMap_[u][v][2]), 
									   createVector(this.structures_[index+1].colorMap_[u][v][0],
													this.structures_[index+1].colorMap_[u][v][1],
													this.structures_[index+1].colorMap_[u][v][2]), subLerp);

				return [pos, color]
			}

			FillShapeForLerp(lerpVal) {
				if (this.structures_.length == 1) {
					return;
				}
				
				lerpVal = map(lerpVal, 0, 1, 0, .9999999999);

				let newLerp = lerpVal * (this.structures_.length-1);

				let index = Math.floor(newLerp);
				let subLerp = newLerp - index;

				this.shape_ = [];
				this.colorMap_ = [];
				for (let i = 0; i < this.structures_[index].rows_; i++) {
					this.shape_[i] = [];
					this.colorMap_[i] = [];
					for (let j = 0; j < this.structures_[index].cols_; j++) {
						let out = this.GetCoord(i,j,index, subLerp);

						this.shape_[i][j] = out[0];
						this.colorMap_[i][j] = [out[1].x, out[1].y, out[1].z];
					}
				}
			}

			Draw() {
				for (let i = 0; i < this.rows_-1; i++) {
					for (let j = 0; j < this.cols_-1; j++) {
						beginShape(drawMode);
						fill(this.colorMap_[i][j]);

						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i+1][j].x, this.shape_[i+1][j].y, this.shape_[i+1][j].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();

						
						beginShape(drawMode);
						fill(this.colorMap_[i][j][0], this.colorMap_[i][j][1], this.colorMap_[i][j][2]);
						
						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i][j+1].x, this.shape_[i][j+1].y, this.shape_[i][j+1].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();
					}
				}
			}
		}

		function draw() {
			// for (let i = 0; i < rows; i++) {
			// 	plane[i] = [];
			// 	for (let j = 0; j < cols; j++) {
			// 		plane[i][j] = p5.Vector.lerp(initialPlane[i][j], finalShape[i][j], lerpVal)
			// 	}
			// }
			
			if (lerpStep >= 1 || lerpStep <= 0) {
				count += 1;
				if (count > countMax) {
					lerpDir *= -1;
					count = 0;
					lerpStep += .01*lerpDir;
				}
			} else {
				lerpStep += .01*lerpDir;
			}
			lerpStep = Math.min(1, Math.max(0, lerpStep));
			
			background(230,50,15);

			// move and rotate camera
			orbitControl(4,4);
			
			//Structure.focused.Draw();
			collection.FillShapeForLerp(lerpStep);
			collection.Draw();
			
		}

	</script>
</body>

</html>