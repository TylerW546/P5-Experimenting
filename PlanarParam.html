<!DOCTYPE html>
<html>

<head>
	<title>Planar Parameterization</title>
	<script src="p5.js"></script>
	<style>
		canvas {
			display: block;
			margin: 0 auto;
		}
	</style>
</head>



<body>
	<script>
		let rows = 20;
		let cols = 360;
		let scl = 250;
		let w = 1000;
		let h = 1000;

		let plane = [];

		let initialPlane = [];
		let finalShape = [];
		let colorMap = [];

		let lerpVal = 0;
		let lerpDir = 1;

		let count = 0;
		let countMax = 50;

		let camX = 0;
		let camY = -200;
		let camZ = 500;

		var drawMode;

		function setup() {
			createCanvas(w, h, WEBGL);
			drawMode = TRIANGLES;
			angleMode(DEGREES);
			colorMode(HSB);

			//stroke(205,50,100);
			//strokeWeight(4);
			noStroke();
			//noFill();

			for (let i = 0; i < rows; i++) {
				finalShape[i] = [];
				initialPlane[i] = [];
				colorMap[i] = [];
				for (let j = 0; j < cols; j++) {
					//let u = map(i/rows,0,1-1/rows,0,2*Math.PI)-Math.PI/2;
					//let v = map(j/cols,0,1-1/cols,0,2*Math.PI)+Math.PI;
					let u = i/(rows-1);
					let v = j/(cols-1);

					let out = flowerShape(u,v);
					let vect = out[0];
					let color = out[1];
					vect.mult(scl);
					finalShape[i][j] = vect;
					colorMap[i][j] = color;
					initialPlane[i][j] = createVector( 	scl*u*sin(map(v, 0, 1, 0, 7.5 * 2 * 180)),//-10*i+rows/2*10,
														-scl*(u-.5),
														scl*u*cos(map(v, 0, 1, 0, 7.5 * 2 * 180)));
										
					initialPlane[i][j] = createVector( 	-scl*(u-.5),
														scl*2*(v-1),
														0);
					
					initialPlane[i][j] = createVector( 	scl*u*sin(map(v, 0, 1, 0, 7.5 * 2 * 180)),
														10*scl*(v-1),
														scl*u*cos(map(v, 0, 1, 0, 7.5 * 2 * 180)));
				}
			}
		}

		function donut(u, v) {
			return createVector((cos(v)+2)*cos(u),
					(cos(v)+2)*sin(u),
					sin(v));//-u/2;
		}

		// Rose[x_, theta_] := Module[
		// 	{phi = (Pi/2)Exp[-theta/(8 Pi)], 
		//	X = 1 - (1/2) ( (5/4) (1 - Mod[3.6 theta, 2 Pi]/Pi)^2 - 1/4)^2}, 
		// 	y = 1.95653 x^2 (1.27689 x - 1)^2 Sin[phi];
		// 	r = X(x Sin[phi] + y Cos[phi]); 
		// 	{r Sin[theta], r Cos[theta], X(x Cos[phi] - y Sin[phi]), EdgeForm[]}
		// ];
		// ParametricPlot3D[Rose[x, theta], {x, 0, 1}, {theta, -2 Pi, 15 Pi}, PlotPoints -> {25, 576}, LightSources -> {{{0, 0, 1}, RGBColor[1, 0, 0]}}, Compiled -> False]

		function sphereShape(phi, theta) {
			phi = map(phi, 0, 1, 0, 2*180);
			theta = map(theta, 0, 1, 0, 180);

			let pX = sin(phi) * sin(theta);
			let pY = cos(phi);
			let pZ = sin(phi) * cos(theta);

			return createVector(pX, -pY, pZ);
		}

		function flowerShape(r, theta) {
			//phi = map(phi, 0, 1, 0, 2*Math.PI);
			let color = [0, -r*50+100, r*50+50];
			
			let circles = 7.5;

			theta = map(theta, 0, 1, 0, circles*2 * 180);
			let phi = 15*Math.exp(theta/1500);

			let petalCut = 1 - (1/2) * pow((1) * (1 - ((3.6*theta%360)/180)), 4);
			let hangDown = 1.95653*pow(r,2)*pow(1.27689*r-1,2)*sin(phi);

			let pX = petalCut * r * sin(phi) * sin(theta);
			let pY = petalCut * (r * cos(phi)-hangDown);
			let pZ = petalCut * r * sin(phi) * cos(theta);

			return [createVector(pX, -pY, pZ), color];
		}

		function draw() {
			for (let i = 0; i < rows; i++) {
				plane[i] = [];
				for (let j = 0; j < cols; j++) {
					plane[i][j] = p5.Vector.lerp(initialPlane[i][j], finalShape[i][j], lerpVal)
				}
			}
			
			if (lerpVal > 1 || lerpVal < 0) {
				count += 1;
				if (count > countMax) {
					lerpDir *= -1;
					count = 0;
					lerpVal += .01*lerpDir;
				}
			} else {
				lerpVal += .01*lerpDir;
			}
			
			background(230,50,15);

			// move and rotate camera
			orbitControl(4,4);

			// draw terrain
			for (let i = 0; i < rows-1; i++) {
				
				for (let j = 0; j < cols-1; j++) {
					beginShape(drawMode);
					//fill(0,0,i/rows*100+155);
					//fill(map(noise(i/rows*3), 0, 1, 0, 255), map(noise(j/cols*3), 0, 1, 0, 255), 0)
					fill(colorMap[i][j]);
					vertex(plane[i][j].x, plane[i][j].y, plane[i][j].z);
					vertex(plane[i+1][j].x, plane[i+1][j].y, plane[i+1][j].z);
					vertex(plane[i+1][j+1].x, plane[i+1][j+1].y, plane[i+1][j+1].z);

					endShape();

					beginShape(drawMode);

					// //fill(map(noise(i/rows*3), 0, 1, 0, 100), map(noise(j/cols*3), 0, 1, 0, 100),0)

					vertex(plane[i][j].x, plane[i][j].y, plane[i][j].z);
					vertex(plane[i][j+1].x, plane[i][j+1].y, plane[i][j+1].z);
					vertex(plane[i+1][j+1].x, plane[i+1][j+1].y, plane[i+1][j+1].z);

					endShape();
				}
			}

			// fillLRSeams();
			// fillTBSeams();
			// fillLastSeam();
		}

		function fillLRSeams() {
			for (let i = 0; i < rows-1; i++) {
				beginShape();
				fill(0,0,i/rows*100+155);
				
				vertex(plane[i][cols-1].x, plane[i][cols-1].y, plane[i][cols-1].z);
				vertex(plane[i+1][cols-1].x, plane[i+1][cols-1].y, plane[i+1][cols-1].z);
				vertex(plane[i+1][0].x, plane[i+1][0].y, plane[i+1][0].z);

				vertex(plane[i][cols-1].x, plane[i][cols-1].y, plane[i][cols-1].z);
				vertex(plane[i][0].x, plane[i][0].y, plane[i][0].z);
				vertex(plane[i+1][0].x, plane[i+1][0].y, plane[i+1][0].z);
				
				endShape();
			}
		}

		function fillTBSeams() {
			for (let j = 0; j < cols-1; j++) {
				beginShape();
				fill(0,0,155);
				vertex(plane[rows-1][j].x, plane[rows-1][j].y, plane[rows-1][j].z);
				vertex(plane[0][j].x, plane[0][j].y, plane[0][j].z);
				vertex(plane[0][j+1].x, plane[0][j+1].y, plane[0][j+1].z);

				vertex(plane[rows-1][j].x, plane[rows-1][j].y, plane[rows-1][j].z);
				vertex(plane[rows-1][j+1].x, plane[rows-1][j+1].y, plane[rows-1][j+1].z);
				vertex(plane[0][j+1].x, plane[0][j+1].y, plane[0][j+1].z);
				endShape();
			}
		}

		function fillLastSeam() {
			beginShape();
			fill(0,0,0/rows*100+155);
			
			vertex(plane[rows-1][cols-1].x, plane[rows-1][cols-1].y, plane[rows-1][cols-1].z);
			vertex(plane[0][cols-1].x, plane[0][cols-1].y, plane[0][cols-1].z);
			vertex(plane[0][0].x, plane[0][0].y, plane[0][0].z);

			vertex(plane[rows-1][cols-1].x, plane[rows-1][cols-1].y, plane[rows-1][cols-1].z);
			vertex(plane[rows-1][0].x, plane[rows-1][0].y, plane[rows-1][0].z);
			vertex(plane[0][0].x, plane[0][0].y, plane[0][0].z);
			
			endShape();
		}

	</script>
</body>

</html>