<!DOCTYPE html>
<html>

<head>
	<title>Planar Parameterization</title>
	<script src="p5.js"></script>
	<style>
		canvas {
			display: block;
			margin: 0 auto;
		}
	</style>
</head>



<body>
	<script>
		let rows = 32;
		let cols = 64;
		let scalar = 100;
		let w = 1000;
		let h = 1000;

		let plane = [];

		let initialPlane = [];
		let finalShape = [];
		let colorMap = [];

		let lerpStep = 0;
		let lerpDir = -1;

		let count = 0;
		let countMax = 0;

		let camX = 0;
		let camY = -200;
		let camZ = 500;

		var drawMode;
		var collection;

		class Structure {
			static focused;
			
			constructor(rows, cols, scl = scalar, auto=true) {
				this.rows_ = rows;
				this.cols_ = cols;
				this.scl_ = scl;

				this.shape_ = [];
				this.colorMap_ = [];

				if (auto) {
					this.CreateShape();
				}
			}

			DefineCoordinates(u, v) {
				let phi = map(u, 0, 1, 0, 1*180);
				let theta = map(v, 0, 1, 0, 2*180);

				let pX = sin(phi) * sin(theta);
				let pY = cos(phi);
				let pZ = sin(phi) * cos(theta);

				return [createVector(pX, -pY, pZ), [50, 50, 100-map(phi, 0, 1*180, 0, 100)]];
			}

			CreateShape() {
				for (let i = 0; i < this.rows_; i++) {
					this.shape_[i] = [];
					this.colorMap_[i] = [];
					for (let j = 0; j < this.cols_; j++) {
						let u = i/(this.rows_-1);
						let v = j/(this.cols_-1);

						let out = this.DefineCoordinates(u,v);
						let vect = out[0];
						let color = out[1];
						vect.mult(this.scl_);

						this.shape_[i][j] = vect;
						this.colorMap_[i][j] = color;
					}
				}
			}

			SetFocused() {
				Structure.focused = this;
			}

			Draw() {
				for (let i = 0; i < this.rows_-1; i++) {
					for (let j = 0; j < this.cols_-1; j++) {
						beginShape(drawMode);
						fill(this.colorMap_[i][j]);

						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i+1][j].x, this.shape_[i+1][j].y, this.shape_[i+1][j].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();

						
						beginShape(drawMode);
						fill(this.colorMap_[i][j][0], this.colorMap_[i][j][1], this.colorMap_[i][j][2]-10);
						
						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i][j+1].x, this.shape_[i][j+1].y, this.shape_[i][j+1].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();
					}
				}
			}
		}

		class Donut extends Structure {
			DefineCoordinates(v, u) {
				u = map(u, 0, 1, 0, 2*180);
				v = map(v, 0, 1, 0, 2*180);
				
				let pX = (cos(v)+2)*cos(u);
				let pY = (cos(v)+2)*sin(u);
				let pZ = sin(v);

				let pos = createVector(pY, -pZ, pX);
					
				let color = [100,100,50];

				return [pos, color];
			}
		}

		class Rose extends Structure {
			DefineCoordinates(r, theta) {
				//phi = map(phi, 0, 1, 0, 2*Math.PI);
				let color = [0, -r*50+100, r*50+50];
				
				let circles = 7.5;

				theta = map(theta, 0, 1, 0, circles*2 * 180);
				let phi = 15*Math.exp(theta/1500);

				let petalCut = 1 - (1/2) * pow((1) * (1 - ((3.6*theta%360)/180)), 4);
				let hangDown = 1.95653*pow(r,2)*pow(1.27689*r-1,2)*sin(phi);

				let pX = petalCut * r * sin(phi) * sin(theta);
				let pY = petalCut * (r * cos(phi)-hangDown);
				let pZ = petalCut * r * sin(phi) * cos(theta);

				return [createVector(pX, -pY, pZ), color];
			}
		}

		class Spiral extends Structure {
			DefineCoordinates(u, v) {
				return [createVector(u*sin(map(v, 0, 1, 0, 7.5 * 2 * 180)),
									10*(v-1),
									u*cos(map(v, 0, 1, 0, 7.5 * 2 * 180))), [0, -u*50+100, u*50+50]];
			}
		}

		class Metagon extends Structure {
			constructor(rows, cols, scl = scalar) {
				super(rows, cols, scl, false);
				
				this.metagonData = [];

				let a = 60;

				let pointCount = 0;
				
				for (let sides = 3; pointCount < this.cols_+20 ; sides++) {
					this.metagonData.push([]);

					for (let vert = 0; vert < sides; vert++) {
						var lastPoint;
						if (vert > 0) {
							lastPoint = this.metagonData[this.metagonData.length-1][this.metagonData[this.metagonData.length-1].length-1];
						} else {
							if (this.metagonData.length == 1) {
								this.metagonData[0][0] = createVector(0,0);
								pointCount++;
								lastPoint = this.metagonData[0][0];
							} else {
								lastPoint = this.metagonData[this.metagonData.length-2][this.metagonData[this.metagonData.length-2].length-3];
								a+=2*360/(sides-1)
							}
						}
						this.metagonData[this.metagonData.length-1].push(createVector(lastPoint.x+cos(a), lastPoint.y+sin(a)));
						pointCount++;

						a -= 360/sides;
					}
				}
				this.CreateShape();
			}
			
			DefineCoordinates(u, v) {
				v = floor(map(v, 0, 1, 0, this.cols_));
				//console.log(u,v);
				
				var shape;
				var extra;

				color = [(-shape/5*150+360+120)%360,255,255]
				
				if (v < 2) {
					shape = 0;
					extra = floor(v);
				} else {
					shape = sqrt(2*v-1.75)-.5;
					extra = floor(v-(floor(shape)*floor(shape)+floor(shape)+2)/2);
				} 

				console.log(floor(shape), extra);
				
				return [createVector(this.metagonData[floor(shape)][floor(extra)].x*u,v/10,this.metagonData[floor(shape)][floor(extra)].y*u), color];
			}
		}

		class Collection {
			constructor(structs) {
				// for (let i = 0; i < structs.length-1; i++) {
				// 	assert(structs[i].rows_ == structs[i+1].rows_ && structs[i].cols_ == structs[i+1].cols_, "Array sizes not compatible");
				// }

				this.structures_ = structs;
				this.shape_ = structs[0].shape_;
				this.colorMap_ = structs[0].colorMap_;
				this.rows_ = structs[0].rows_;
				this.cols_ = structs[0].cols_;
			}

			GetCoord(u, v, index, subLerp) {
				let pos = p5.Vector.lerp(this.structures_[index].shape_[u][v], this.structures_[index+1].shape_[u][v], subLerp)
				let color = p5.Vector.lerp(createVector(this.structures_[index].colorMap_[u][v][0],
													this.structures_[index].colorMap_[u][v][1],
													this.structures_[index].colorMap_[u][v][2]), 
									   createVector(this.structures_[index+1].colorMap_[u][v][0],
													this.structures_[index+1].colorMap_[u][v][1],
													this.structures_[index+1].colorMap_[u][v][2]), subLerp);

				return [pos, color]
			}

			FillShapeForLerp(lerpVal) {
				lerpVal = map(lerpVal, 0, 1, 0, .9999999999);

				let newLerp = lerpVal * (this.structures_.length-1);

				let index = Math.floor(newLerp);
				let subLerp = newLerp - index;

				this.shape_ = [];
				this.colorMap_ = [];
				for (let i = 0; i < this.structures_[index].rows_; i++) {
					this.shape_[i] = [];
					this.colorMap_[i] = [];
					for (let j = 0; j < this.structures_[index].cols_; j++) {
						let out = this.GetCoord(i,j,index, subLerp);

						this.shape_[i][j] = out[0];
						this.colorMap_[i][j] = [out[1].x, out[1].y, out[1].z];
					}
				}
			}

			Draw() {
				for (let i = 0; i < this.rows_-1; i++) {
					for (let j = 0; j < this.cols_-1; j++) {
						beginShape(drawMode);
						fill(this.colorMap_[i][j]);

						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i+1][j].x, this.shape_[i+1][j].y, this.shape_[i+1][j].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();

						
						beginShape(drawMode);
						fill(this.colorMap_[i][j][0], this.colorMap_[i][j][1], this.colorMap_[i][j][2]-10);
						
						vertex(this.shape_[i][j].x, this.shape_[i][j].y, this.shape_[i][j].z);
						vertex(this.shape_[i][j+1].x, this.shape_[i][j+1].y, this.shape_[i][j+1].z);
						vertex(this.shape_[i+1][j+1].x, this.shape_[i+1][j+1].y, this.shape_[i+1][j+1].z);

						endShape();
					}
				}
			}


		}

		function setup() {
			createCanvas(w, h, WEBGL);
			drawMode = TRIANGLES;
			angleMode(DEGREES);
			colorMode(HSB);

			struct = new Structure(rows, cols);
			struct.SetFocused();

			donut = new Donut(rows, cols);
			donut.SetFocused();

			spiral = new Spiral(rows, cols);
			spiral.SetFocused();

			rose = new Rose(rows, cols);
			rose.SetFocused();

			meta = new Metagon(2, 20);
			meta.SetFocused();

			//collection = new Collection([struct, donut, spiral, rose]);
			//collection.FillShapeForLerp(1);

			stroke(205,50,100);
			strokeWeight(1);
			//noStroke();
			//noFill();
			
		}


		function draw() {
			// for (let i = 0; i < rows; i++) {
			// 	plane[i] = [];
			// 	for (let j = 0; j < cols; j++) {
			// 		plane[i][j] = p5.Vector.lerp(initialPlane[i][j], finalShape[i][j], lerpVal)
			// 	}
			// }
			
			if (lerpStep >= 1 || lerpStep <= 0) {
				count += 1;
				if (count > countMax) {
					lerpDir *= -1;
					count = 0;
					lerpStep += .01*lerpDir;
				}
			} else {
				lerpStep += .01*lerpDir;
			}
			lerpStep = Math.min(1, Math.max(0, lerpStep));
			
			background(230,50,15);

			// move and rotate camera
			orbitControl(4,4);
			
			Structure.focused.Draw();
			// collection.FillShapeForLerp(lerpStep);
			// collection.Draw();
			
		}

	</script>
</body>

</html>