<!DOCTYPE html>
<html>
<head>
	<title>Orbits</title>
</head>
<body>
	<script src = "p5.js"></script>
	<script type="text/javascript">
		var timeCount = 0;


        var scaleFactor = 20;

        var G = (2*3.1415926)^2;

        var timeScale = 0;
        var dt=.001;
        var timeScaleMultiplier = 1;

        var maxLen = 500;

        var initialCOM;
        var posCOM;

        var initialVCOM;
        
        //https://astronomy.stackexchange.com/questions/37217/binary-star-initial-speed

        function setup(){
            createCanvas(2000, 1000, WEBGL);
			angleMode(DEGREES);
            colorMode(HSL, 360)

            new Satellite(10,0,0,m=1e1,r=35,dx=0,dy=4,dz=0);
            new Satellite(0,0,10,m=1e1,r=35,dx=0,dy=-3,dz=0);
            new Satellite(-15,0,0,m=1e-1,r=5,dx=0,dy=3,dz=0);
            new Satellite(0,10,0,m=1,r=15,dx=0,dy=-5.3,dz=0);
            new Satellite(0,-10,0,m=1,r=15,dx=0,dy=-5,dz=0);

            // new Satellite(10,0,-10,m=1e-10,r=15,dx=0,dy=4,dz=0);
            // new Satellite(-10,0,-10,m=1e-10,r=15,dx=0,dy=4,dz=0);
            // new Satellite(10,0,10,m=1e-10,r=15,dx=0,dy=-4,dz=0);
            // new Satellite(-10,0,10,m=1e-10,r=15,dx=0,dy=-4,dz=0);
            // new Satellite(0,0,0,m=1e2,r=45,dx=0,dy=0,dz=0);

            // new Satellite(-80,0,0,m=1e-8,r=40,dx=0,dy=0,dz=0);
            // new Satellite(80,56.5685424949,0,m=1e-20,r=40,dx=-3,dy=0,dz=0);

            initialCOM = getCOM();
            initialVCOM = getVCOM();
		}

        function randomColor() {
            return color(random(360),100,100);
        }

        function getCOM() {
            var sum = createVector(0,0,0);
            var totalMass = 0;
            for (var i=0; i<Satellite.allObjects.length; i++) {
                var mass = Satellite.allObjects[i].mass;
                sum.add(p5.Vector.mult(Satellite.allObjects[i].pos,mass));
                totalMass += mass
            }
            return sum.mult(1/totalMass);
        }

        function getVCOM() {
            var sum = createVector(0,0,0);
            var totalMass = 0;
            for (var i=0; i<Satellite.allObjects.length; i++) {
                var mass = Satellite.allObjects[i].mass;
                sum.add(p5.Vector.mult(Satellite.allObjects[i].velocity,mass));
                totalMass += mass
            }
            return sum.mult(1/totalMass);
        }

        function decomposeXToY(x,y) {
            var proj = p5.Vector.mult(y, x.dot(y)/y.mag()**2);
            var orth = p5.Vector.sub(x,proj);

            return [proj, orth];
        }

        function renderSphere(pos,radius=10,fillColor=255,strokeWidth=0,strokeColor=color(255)) {
            fill(fillColor);
            noStroke();
            if (strokeWidth) {
                stroke(strokeColor)
            }
            
            push(); // enter local coordinate system
            translate(pos.x*scaleFactor, pos.y*scaleFactor, pos.z*scaleFactor);
            //sphere(this.radius*scaleFactor);
            sphere(radius);
            pop();
        }

        class Satellite {
            static allObjects = [];
            
            constructor(x,y,z,m=100,r=10,dx=0,dy=0,dz=0) {
                this.pos = createVector(x,y,z);
                this.velocity = createVector(dx,dy,dz);
                this.acceleration = createVector(0,0,0);

                this.mass = m;
                this.radius = r;
                this.color = randomColor();

                this.positions = [];

                this.new_velocity = null;

                this.colliding_with = [];

                Satellite.allObjects.push(this);
            }

            calc() {
                for (var i=0; i<Satellite.allObjects.length; i++) {
                    var body = Satellite.allObjects[i];

                    if (body != this) {
                        var dist = p5.Vector.dist(this.pos,body.pos);
                        if (dist*scaleFactor > this.radius+body.radius) {
                            var acel = G*body.mass/dist**2/dt;
                            var bodyPos = p5.Vector.sub(body.pos, this.pos);
                            bodyPos = p5.Vector.mult(bodyPos.setMag(6.28*acel),dt);
                            this.acceleration = p5.Vector.add(this.acceleration, bodyPos);
                        } else {
                            this.colliding_with.push(body);
                        }
                    }
                }

                while(this.colliding_with.length > 0) {
                    this.elasticCollideForce(this.colliding_with[0]);
                    this.removeCollisionForces(this.colliding_with[0]);

                    this.colliding_with.shift()
                }
            }

            elasticCollideForce(body) {
                var x = this.velocity.x*this.mass + body.velocity.x*body.mass - this.velocity.x*body.mass + body.velocity.x*body.mass;
                var y = this.velocity.y*this.mass + body.velocity.y*body.mass - this.velocity.y*body.mass + body.velocity.y*body.mass;
                var z = this.velocity.z*this.mass + body.velocity.z*body.mass - this.velocity.z*body.mass + body.velocity.z*body.mass;
                var totalMass = (this.mass+body.mass);
                
                // Delta Momentum / this.mass
                var accel = createVector(x/totalMass-this.velocity.x,y/totalMass-this.velocity.y,z/totalMass-this.velocity.z);
                // Delta Momentum / (mass * dt) = accel needed to bounce
                accel.div(dt);

                var proj = decomposeXToY(accel, p5.Vector.sub(body.pos,this.pos))[0];
                //proj.mult(-1);
                //proj.setMag(accel.mag());

                this.acceleration.add(proj);
            }

            removeCollisionForces(body) {
                var delta = p5.Vector.sub(body.pos,this.pos);

                var proj, orth = decomposeXToY(this.acceleration, delta);
                if (delta.dot(proj) > 1) {
                    this.acceleration = proj;
                }
            }

            move(i) {
                this.velocity = p5.Vector.add(this.velocity, p5.Vector.mult(this.acceleration,dt));
                
                this.acceleration = createVector(0,0,0);
                this.pos = p5.Vector.add(this.pos, p5.Vector.mult(this.velocity,dt));

                if (i%(1/dt)==0) {
                    if (timeCount%1==0) {
                        this.positions.unshift(this.pos);
                        if (this.positions.length > maxLen) {
                            this.positions.pop();
                        }
                    }
                }
            }

            draw() {
                renderSphere(this.pos,this.radius,this.color,0)

                stroke(this.color);
                strokeWeight(1);
                noFill();

                beginShape(LINES);
                for (var i=0; i < this.positions.length-1; i++) {
                    vertex(this.positions[i].x*scaleFactor, this.positions[i].y*scaleFactor, this.positions[i].z*scaleFactor);
                    vertex(this.positions[i+1].x*scaleFactor, this.positions[i+1].y*scaleFactor, this.positions[i+1].z*scaleFactor);
                }
                endShape();
            }
                
        }

		function draw() {
			background(0);
			
			fill(100,0,0);

			stroke(120,0,0);
			strokeWeight(0.5);

            //noStroke();

            orbitControl(4,4);
		
			lights();
			directionalLight(128, 128, 128, cos(timeCount), sin(timeCount), -1);
			
			
            if (!keyIsDown(32)) {
                for (var i = 0; i < timeScale/dt; i++) {
                    for (let j=0; j<Satellite.allObjects.length; j++) {
                        Satellite.allObjects[j].calc();
                    }
                    for (let j=0; j<Satellite.allObjects.length; j++) {
                        Satellite.allObjects[j].move(i);
                    }
                }
            }
            for (let j=0; j<Satellite.allObjects.length; j++) {
                Satellite.allObjects[j].draw();
            }

            if (keyIsDown(SHIFT)) {
                timeScaleMultiplier = .1;
            } else {
                timeScaleMultiplier = 1;
            }
            if (keyIsDown(LEFT_ARROW)) {
                timeScale -= .01*timeScaleMultiplier;
                console.log(timeScale);
            } 
            if (keyIsDown(RIGHT_ARROW)) {
                timeScale += .01*timeScaleMultiplier;
                console.log(timeScale);
            }

            timeScale = min(5,max(0,timeScale))
            
            posCOM = getCOM();
            renderSphere(posCOM);

            //console.log(p5.Vector.sub(initialVCOM,getVCOM()).mag());

            timeCount++;
		}


	</script>
</body>
</html>























